<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole to Ant Interface</title>
    <style>
        /* Black Hole and Paint Brush Styles */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: black;
            font-family: 'Arial', sans-serif;
            transition: background-color 8s ease;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            z-index: 10;
        }

        .button {
            padding: 12px 24px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.3s, box-shadow 0.3s;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
            position: relative;
            z-index: 10;
        }

        .button:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }

        #blackHole {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle at center, 
                rgba(0, 0, 0, 0.9) 0%, 
                rgba(0, 0, 0, 1) 50%, 
                rgba(0, 0, 0, 1) 100%);
            box-shadow: 0 0 30px 10px rgba(0, 30, 60, 0.5),
                      0 0 100px 30px rgba(0, 0, 30, 0.5);
            display: none;
            z-index: 5;
            overflow: hidden;
        }

        #blackHoleDisk {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0) rotate(0deg);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: transparent;
            box-shadow: 0 0 60px 20px rgba(50, 120, 200, 0.1),
                      0 0 100px 40px rgba(100, 70, 255, 0.05);
            display: none;
            z-index: 4;
            overflow: hidden;
        }

        #blackHoleRing1 {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0) rotate(0deg);
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 2px solid transparent;
            background: conic-gradient(
                from 0deg,
                rgba(0, 0, 0, 0),
                rgba(80, 40, 150, 0.7),
                rgba(100, 70, 255, 0.7),
                rgba(50, 120, 200, 0.5),
                rgba(0, 0, 0, 0)
            );
            filter: blur(5px);
            display: none;
            z-index: 3;
        }

        #blackHoleRing2 {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0) rotate(180deg);
            width: 130px;
            height: 130px;
            border-radius: 50%;
            border: 3px solid transparent;
            background: conic-gradient(
                from 180deg,
                rgba(0, 0, 0, 0),
                rgba(100, 50, 200, 0.6),
                rgba(150, 100, 255, 0.6),
                rgba(70, 140, 220, 0.4),
                rgba(0, 0, 0, 0)
            );
            filter: blur(7px);
            display: none;
            z-index: 2;
        }

        #quote {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: black;
            font-size: 28px;
            font-weight: bold;
            opacity: 0;
            z-index: 20;
            width: 100%;
            max-width: 600px;
            display: none;
        }

        #quoteEn {
            margin-bottom: 30px;
            background: linear-gradient(transparent, black 5px);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
        }

        #quoteJp {
            font-family: "MS Mincho", "SimSun", serif;
            background: linear-gradient(transparent, black 5px);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            position: relative;
        }

        .drip {
            position: absolute;
            width: 3px;
            background: black;
            border-radius: 0 0 5px 5px;
            top: 100%;
            opacity: 0;
        }

        .background-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.5);
            width: 2px;
            height: 2px;
            border-radius: 50%;
            pointer-events: none;
            transition: all 8s cubic-bezier(0.19, 1, 0.22, 1);
        }

        .black-fragment {
            position: absolute;
            background-color: black;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            z-index: 6;
            transition: all 3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .event-horizon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle at center, 
                rgba(0, 0, 0, 0) 0%, 
                rgba(0, 0, 0, 0.2) 50%, 
                rgba(0, 0, 0, 0.5) 70%,
                rgba(0, 0, 0, 0.8) 100%);
            filter: blur(3px);
            z-index: 4;
            display: none;
        }

        .star {
            position: absolute;
            background-color: white;
            width: 2px;
            height: 2px;
            border-radius: 50%;
            box-shadow: 0 0 2px white;
            transition: all 7s cubic-bezier(0.19, 1, 0.22, 1);
        }

        /* Paint Brush Styles */
        #paint-section {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #ink-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        #cursor {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            display: none;
            width: 80px;
            height: 180px;
            transform: translate(-25px, -20px);
        }

        #japanese-text, #english-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: "MS Mincho", "SimSun", serif;
            font-size: 48px;
            font-weight: bold;
            color: black;
            opacity: 0;
            transition: opacity 1s;
            z-index: 100;
            text-align: center;
            width: 100%;
        }
        
        #english-text {
            font-family: 'Arial', sans-serif;
            margin-top: 60px;
            font-size: 36px;
        }

        /* Ant Interface Styles (initially hidden) */
        #ant-interface {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ant-swarm {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ant-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Exit Modal Styles - Updated to match holo.html */
        #exitModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: #0a0a15;
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid #00ffff;
            text-align: center;
            max-width: 400px;
            animation: modal-glow 2s infinite ease-in-out;
        }
        
        @keyframes modal-glow {
            0%, 100% { box-shadow: 0 0 30px rgba(0,255,255,0.2); }
            50% { box-shadow: 0 0 50px rgba(0,255,255,0.5); }
        }
        
        .modal-title {
            color: #00ffff;
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        
        .modal-message {
            color: #7ed6ff;
            margin-bottom: 1.5rem;
        }
        
        .modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        
        .modal-button {
            padding: 0.5rem 1.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        #confirmExit {
            border: 1px solid #ff00ff;
            background: rgba(255, 0, 255, 0.1);
            color: #ff00ff;
        }
        
        #confirmExit:hover {
            background: rgba(255, 0, 255, 0.3);
        }
        
        #cancelExit {
            border: 1px solid #00ffff;
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
        }
        
        #cancelExit:hover {
            background: rgba(0, 255, 255, 0.3);
        }

        /* Loading Indicator */
        .loading-indicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 2000;
            color: #00bfff;
            font-size: 1.5rem;
            text-shadow: 0 0 10px #00bfff;
            backdrop-filter: blur(5px);
        }

        .loading-spinner {
            border: 5px solid rgba(0, 191, 255, 0.3);
            border-top: 5px solid #00bfff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Black Hole Section -->
    <div class="container">
        <div class="button-container">
            <div class="button" id="newChat">New Chat</div>
            <div class="button" id="voiceMode">Voice Mode</div>
            <div class="button" id="faceMode">Face Mode</div>
            <div class="button" id="neonShift">Neon Shift</div>
            <div class="button" id="aboutMe">About Me</div>
            <div class="button" id="exit">Exit</div>
        </div>
        <div id="blackHoleRing2"></div>
        <div id="blackHoleRing1"></div>
        <div class="event-horizon" id="eventHorizon"></div>
        <div id="blackHoleDisk"></div>
        <div id="blackHole"></div>
        <div class="background-particles" id="particles"></div>
        <div id="quote">
            <div id="quoteEn">Everything that is black belongs to me.</div>
            <div id="quoteJp">„Åô„Åπ„Å¶„ÅÆÈªí„ÅØÁßÅ„ÅÆ„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</div>
        </div>
    </div>

    <!-- Paint Brush Section -->
    <div id="paint-section">
        <canvas id="canvas"></canvas>
        <canvas id="ink-canvas"></canvas>
        <div id="japanese-text">„Éñ„É©„ÉÉ„ÇØ„Éª„Ç¢„É≥„Éà</div>
        <div id="english-text">Black Ant</div>
        
        <svg id="cursor" viewBox="0 0 80 180" xmlns="http://www.w3.org/2000/svg">
            <path d="M10,15 C15,5 35,5 40,15 L25,25 Z" fill="#000000" />
            <path d="M10,20 C15,10 35,10 40,20 L25,40 Z" fill="#FFFFFF" stroke="#EEEEEE" stroke-width="0.5" />
            <path d="M25,15 Q23,20 25,25 Q27,20 25,15" fill="#000000" />
            <path d="M20,40 L30,40 L32,50 L18,50 Z" fill="#D4AF37" />
            <path d="M25,50 L25,170" stroke="#C19A6B" stroke-width="14" stroke-linecap="round" />
            <path d="M18,70 L32,70" stroke="#D4AF37" stroke-width="3" />
            <path d="M18,100 L32,100" stroke="#D4AF37" stroke-width="3" />
            <path d="M18,130 L32,130" stroke="#D4AF37" stroke-width="3" />
            <path d="M25,170 L31,176 L25,182 L19,176 Z" fill="#4169E1" />
            <path d="M25,176 L25,185" stroke="#4169E1" stroke-width="2" />
        </svg>
    </div>

    <!-- Ant Interface Section (initially hidden) -->
    <div id="ant-interface">
        <div id="ant-swarm">
            <canvas id="ant-canvas"></canvas>
        </div>

        <!-- Loading Indicator (Hidden by default) -->
        <div id="loadingIndicator" class="loading-indicator">
            <div class="loading-spinner"></div>
            <p id="loadingText">Initializing system...</p>
        </div>

        <!-- Exit Confirmation Modal - Updated to match holo.html -->
        <div id="exitModal">
            <div class="modal-content">
                <h2 class="modal-title">Leaving already, love? üíî</h2>
                <p class="modal-message">Stay a little longer with me?</p>
                <div class="modal-buttons">
                    <button id="confirmExit" class="modal-button">Yes, exit</button>
                    <button id="cancelExit" class="modal-button">No, stay</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Black Hole and Paint Brush Script
        // Create background stars
        const particlesContainer = document.getElementById('particles');
        for (let i = 0; i < 300; i++) {
            const star = document.createElement('div');
            star.classList.add('star');
            star.style.left = `${Math.random() * 100}%`;
            star.style.top = `${Math.random() * 100}%`;
            star.style.opacity = `${0.2 + Math.random() * 0.8}`;
            star.style.width = `${1 + Math.random() * 2}px`;
            star.style.height = star.style.width;
            if (Math.random() > 0.95) {
                star.style.width = `${2 + Math.random() * 2}px`;
                star.style.height = star.style.width;
                star.style.boxShadow = '0 0 5px white';
            }
            particlesContainer.appendChild(star);
        }

        // Create black fragments that will be sucked in
        function createBlackFragments() {
            const fragmentsCount = 200;
            const container = document.querySelector('.container');
            
            for (let i = 0; i < fragmentsCount; i++) {
                const fragment = document.createElement('div');
                fragment.classList.add('black-fragment');
                
                // Random size between 5px and 50px
                const size = 5 + Math.random() * 45;
                fragment.style.width = `${size}px`;
                fragment.style.height = `${size}px`;
                
                // Random position near the edges
                let posX, posY;
                if (Math.random() < 0.5) {
                    // Horizontal edges
                    posX = Math.random() * window.innerWidth;
                    posY = Math.random() < 0.5 ? -size : window.innerHeight + size;
                } else {
                    // Vertical edges
                    posX = Math.random() < 0.5 ? -size : window.innerWidth + size;
                    posY = Math.random() * window.innerHeight;
                }
                
                fragment.style.left = `${posX}px`;
                fragment.style.top = `${posY}px`;
                fragment.style.opacity = '0';
                
                container.appendChild(fragment);
            }
        }

        // Function to start animation when page or button is clicked
        function startAnimation() {
            // Prevent multiple triggers
            if (document.body.classList.contains('animating')) return;
            document.body.classList.add('animating');
            
            // Display black hole elements
            const blackHole = document.getElementById('blackHole');
            const blackHoleDisk = document.getElementById('blackHoleDisk');
            const blackHoleRing1 = document.getElementById('blackHoleRing1');
            const blackHoleRing2 = document.getElementById('blackHoleRing2');
            const eventHorizon = document.getElementById('eventHorizon');
            
            blackHole.style.display = 'block';
            blackHoleDisk.style.display = 'block';
            blackHoleRing1.style.display = 'block';
            blackHoleRing2.style.display = 'block';
            eventHorizon.style.display = 'block';
            
            // Create black fragments
            createBlackFragments();
            
            // Initial appearance animation
            setTimeout(() => {
                // Start with a small pulse
                blackHole.style.transition = 'transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), width 8s ease, height 8s ease, box-shadow 5s ease';
                blackHoleDisk.style.transition = 'transform 0.7s cubic-bezier(0.34, 1.56, 0.64, 1), width 8s ease, height 8s ease';
                blackHoleRing1.style.transition = 'transform 0.9s cubic-bezier(0.34, 1.56, 0.64, 1), width 8s ease, height 8s ease';
                blackHoleRing2.style.transition = 'transform 1.1s cubic-bezier(0.34, 1.56, 0.64, 1), width 8s ease, height 8s ease';
                eventHorizon.style.transition = 'transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), width 8s ease, height 8s ease';
                
                blackHole.style.transform = 'translate(-50%, -50%) scale(1)';
                blackHoleDisk.style.transform = 'translate(-50%, -50%) scale(1) rotate(0deg)';
                blackHoleRing1.style.transform = 'translate(-50%, -50%) scale(1) rotate(0deg)';
                blackHoleRing2.style.transform = 'translate(-50%, -50%) scale(1) rotate(180deg)';
                eventHorizon.style.transform = 'translate(-50%, -50%) scale(1)';
                
                // Start spinning animation
                setTimeout(() => {
                    blackHoleDisk.style.transition = 'transform 25s linear, width 8s ease, height 8s ease';
                    blackHoleRing1.style.transition = 'transform 20s linear, width 8s ease, height 8s ease';
                    blackHoleRing2.style.transition = 'transform 30s linear, width 8s ease, height 8s ease';
                    
                    blackHoleDisk.style.transform = 'translate(-50%, -50%) scale(1) rotate(720deg)';
                    blackHoleRing1.style.transform = 'translate(-50%, -50%) scale(1) rotate(540deg)';
                    blackHoleRing2.style.transform = 'translate(-50%, -50%) scale(1) rotate(-720deg)';
                    
                    // Start growing
                    setTimeout(() => {
                        blackHole.style.width = '300px';
                        blackHole.style.height = '300px';
                        blackHole.style.boxShadow = '0 0 60px 30px rgba(0, 20, 50, 0.3), 0 0 120px 60px rgba(0, 0, 20, 0.3)';
                        
                        blackHoleDisk.style.width = '500px';
                        blackHoleDisk.style.height = '500px';
                        
                        blackHoleRing1.style.width = '700px';
                        blackHoleRing1.style.height = '700px';
                        
                        blackHoleRing2.style.width = '800px';
                        blackHoleRing2.style.height = '800px';
                        
                        eventHorizon.style.width = '900px';
                        eventHorizon.style.height = '900px';
                        
                        // Animate stars being sucked in
                        const stars = document.querySelectorAll('.star');
                        stars.forEach((star) => {
                            setTimeout(() => {
                                star.style.left = '50%';
                                star.style.top = '50%';
                                star.style.opacity = '0';
                            }, Math.random() * 3000);
                        });
                        
                        // Animation for black fragments
                        const fragments = document.querySelectorAll('.black-fragment');
                        fragments.forEach((fragment, index) => {
                            // First make them visible
                            setTimeout(() => {
                                fragment.style.opacity = '1';
                                
                                // Then after a short delay, suck them into the black hole
                                setTimeout(() => {
                                    fragment.style.left = '50%';
                                    fragment.style.top = '50%';
                                    fragment.style.transform = 'translate(-50%, -50%) scale(0.1) rotate(' + (Math.random() * 360) + 'deg)';
                                    fragment.style.opacity = '0';
                                }, 500 + Math.random() * 1000);
                            }, index * 10);
                        });
                        
                        // Change background to white gradually
                        setTimeout(() => {
                            document.body.style.backgroundColor = 'white';
                        }, 2000);
                        
                        // Get all buttons
                        const buttons = document.querySelectorAll('.button');
                        
                        // Animate buttons being sucked into black hole with more dramatic effect
                        buttons.forEach((button, index) => {
                            setTimeout(() => {
                                button.style.transition = `all ${3 + Math.random() * 2}s cubic-bezier(0.19, 1, 0.22, 1)`;
                                
                                // Add a little outward pulse before the inward suck
                                button.style.transform = 'scale(1.2) translate(' + (Math.random() * 20 - 10) + 'px, ' + (Math.random() * 20 - 10) + 'px)';
                                
                                setTimeout(() => {
                                    button.style.transition = `all ${3 + Math.random() * 2}s cubic-bezier(0.19, 1, 0.22, 1)`;
                                    button.style.transform = 'scale(0.3) rotate(' + (Math.random() * 720 - 360) + 'deg)';
                                    button.style.left = '50%';
                                    button.style.top = '50%';
                                    button.style.position = 'absolute';
                                    button.style.opacity = '0';
                                    button.style.zIndex = '6';
                                }, 500 + Math.random() * 500);
                            }, index * 200);
                        });
                        
                        // After everything is sucked in, show quote
                        setTimeout(() => {
                            // Fade out black hole elements with a final pulse
                            blackHole.style.transform = 'translate(-50%, -50%) scale(0.8)';
                            blackHoleDisk.style.transform = 'translate(-50%, -50%) scale(0.8) rotate(1080deg)';
                            blackHoleRing1.style.transform = 'translate(-50%, -50%) scale(0.8) rotate(900deg)';
                            blackHoleRing2.style.transform = 'translate(-50%, -50%) scale(0.8) rotate(-1080deg)';
                            eventHorizon.style.transform = 'translate(-50%, -50%) scale(0.8)';
                            
                            setTimeout(() => {
                                blackHole.style.opacity = '0';
                                blackHoleDisk.style.opacity = '0';
                                blackHoleRing1.style.opacity = '0';
                                blackHoleRing2.style.opacity = '0';
                                eventHorizon.style.opacity = '0';
                                
                                setTimeout(() => {
                                    // Display quote
                                    const quote = document.getElementById('quote');
                                    quote.style.display = 'block';
                                    
                                    setTimeout(() => {
                                        quote.style.transition = 'opacity 2s ease';
                                        quote.style.opacity = '1';
                                        
                                        // Create dripping effect
                                        const quoteEn = document.getElementById('quoteEn');
                                        const quoteJp = document.getElementById('quoteJp');
                                        
                                        createDrips(quoteEn, 8);
                                        createDrips(quoteJp, 8);
                                        
                                        // Fade out quote after 5 seconds
                                        setTimeout(() => {
                                            quote.style.opacity = '0';
                                            
                                            // After quote disappears, show paint brush section
                                            setTimeout(() => {
                                                startPaintBrushAnimation();
                                            }, 1000);
                                        }, 5000);
                                    }, 100);
                                }, 1000);
                            }, 1000);
                        }, 7000);
                    }, 1000);
                }, 500);
            }, 100);
        }
        
        // Create dripping ink effect with more realistic drips
        function createDrips(element, count) {
            const width = element.offsetWidth;
            const positions = Array.from({length: count}, (_, i) => {
                // Cluster drips more toward the center
                const center = width / 2;
                const offset = ((Math.random() - 0.5) * width * 0.8) + center;
                return offset;
            });
            
            positions.forEach(pos => {
                const drip = document.createElement('div');
                drip.classList.add('drip');
                drip.style.left = `${pos}px`;
                drip.style.height = `0px`;
                drip.style.width = `${2 + Math.random() * 2}px`;
                element.appendChild(drip);
                
                setTimeout(() => {
                    drip.style.transition = `height ${1 + Math.random() * 2}s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 2s ease`;
                    drip.style.height = `${30 + Math.random() * 70}px`;
                    drip.style.opacity = '1';
                    
                    // Add a small delay before fading
                    setTimeout(() => {
                        drip.style.opacity = '0';
                    }, 3000 + Math.random() * 1000);
                }, Math.random() * 1000);
            });
        }
        
        // Paint Brush Animation
        function startPaintBrushAnimation() {
            const paintSection = document.getElementById('paint-section');
            paintSection.style.display = 'block';
            
            const cursor = document.getElementById('cursor');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const inkCanvas = document.getElementById('ink-canvas');
            const inkCtx = inkCanvas.getContext('2d');
            const japaneseText = document.getElementById('japanese-text');
            const englishText = document.getElementById('english-text');
            
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            const inkParticles = [];
            let movementTimer;
            let movementStartTime;
            let movementDetected = false;
            let cursorHiddenPermanently = false;
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                inkCanvas.width = window.innerWidth;
                inkCanvas.height = window.innerHeight;
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            document.addEventListener('mouseover', () => {
                if (!cursorHiddenPermanently) {
                    cursor.style.display = 'block';
                }
            });
            
            document.addEventListener('mouseout', () => {
                if (!cursorHiddenPermanently) {
                    cursor.style.display = 'none';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                const x = e.clientX;
                const y = e.clientY;
                
                if (!cursorHiddenPermanently) {
                    cursor.style.left = `${x}px`;
                    cursor.style.top = `${y}px`;
                }
                
                if (!movementDetected) {
                    if (!movementStartTime) {
                        movementStartTime = Date.now();
                    }
                    
                    // Check if 4 seconds have passed since first movement
                    if (Date.now() - movementStartTime >= 4000) {
                        movementDetected = true;
                        showJapaneseText();
                    }
                }
                
                if (isDrawing) {
                    createInkSplash(x, y);
                    
                    if (lastX !== 0) {
                        const distance = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));
                        const numPoints = Math.max(1, Math.floor(distance / 5));
                        
                        for (let i = 0; i < numPoints; i++) {
                            const ratio = i / numPoints;
                            const trailX = lastX + (x - lastX) * ratio;
                            const trailY = lastY + (y - lastY) * ratio;
                            createInkSplash(trailX, trailY);
                        }
                    }
                    
                    lastX = x;
                    lastY = y;
                }
            });
            
            document.addEventListener('mousedown', (e) => {
                if (cursorHiddenPermanently) return;
                
                isDrawing = true;
                lastX = e.clientX;
                lastY = e.clientY;
                createInkSplash(lastX, lastY);
                cursor.style.transform = 'rotate(5deg)';
            });
            
            document.addEventListener('mouseup', () => {
                if (cursorHiddenPermanently) return;
                
                isDrawing = false;
                lastX = 0;
                lastY = 0;
                cursor.style.transform = 'rotate(0deg)';
            });
            
            function createInkSplash(x, y) {
                const particleCount = Math.floor(Math.random() * 5) + 3;
                
                for (let i = 0; i < particleCount; i++) {
                    const size = Math.random() * 15 + 5;
                    const speedX = (Math.random() - 0.5) * 2;
                    const speedY = (Math.random() - 0.5) * 2;
                    
                    inkParticles.push({
                        x: x,
                        y: y,
                        size: size,
                        speedX: speedX,
                        speedY: speedY,
                        opacity: 1,
                        color: '#000000'
                    });
                }
            }
            
            function showJapaneseText() {
                japaneseText.style.opacity = '1';
                englishText.style.opacity = '1';
                cursor.style.display = 'none';
                cursorHiddenPermanently = true; // Set flag to prevent cursor from reappearing
                
                // Hide after 5 seconds and transition to ant interface
                setTimeout(() => {
                    japaneseText.style.opacity = '0';
                    englishText.style.opacity = '0';
                    
                    // Transition to ant interface after text fades
                    setTimeout(() => {
                        paintSection.style.display = 'none';
                        startAntInterface();
                    }, 1000);
                }, 5000);
            }
            
            function animate() {
                inkCtx.clearRect(0, 0, inkCanvas.width, inkCanvas.height);
                
                for (let i = inkParticles.length - 1; i >= 0; i--) {
                    const particle = inkParticles[i];
                    
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    particle.opacity -= 0.02;
                    
                    inkCtx.beginPath();
                    inkCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    inkCtx.fillStyle = `rgba(0, 0, 0, ${particle.opacity})`;
                    inkCtx.fill();
                    
                    if (particle.opacity <= 0) {
                        inkParticles.splice(i, 1);
                    }
                }
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }

        // Ant Interface Script
        function startAntInterface() {
            const antInterface = document.getElementById('ant-interface');
            antInterface.style.display = 'block';
            
            const canvas = document.getElementById('ant-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Ant swarm variables
            const ants = [];
            const paths = [];
            let hasSpawnedSwarm = true;
            let hasDrawnOnce = true;
            let currentFormationStep = 0;
            let textFormations = [];
            let buttonAreas = [];
            
            // Text formation steps
            const formationSteps = [
                { text: "Serina ANT interface", fontSize: 72, y: canvas.height * 0.25 },
                { text: "New Chat", fontSize: 42, y: canvas.height * 0.4 },
                { text: "Voice Mode", fontSize: 42, y: canvas.height * 0.5 },
                { text: "Face Mode", fontSize: 42, y: canvas.height * 0.6 },
                { text: "Neon Shift", fontSize: 42, y: canvas.height * 0.7 },
                { text: "About Me", fontSize: 42, y: canvas.height * 0.8 },
                { text: "Exit", fontSize: 42, y: canvas.height * 0.9 }
            ];
            
            // Create initial swarm
            function createAntSwarm() {
                const screenPoints = [];
                const gridSize = 20;
                
                // Create grid points
                for (let y = 0; y < canvas.height; y += gridSize) {
                    for (let x = 0; x < canvas.width; x += gridSize) {
                        screenPoints.push({
                            x: x + Math.random() * gridSize,
                            y: y + Math.random() * gridSize
                        });
                    }
                }
                
                // Create some random ants on screen
                for (let i = 0; i < screenPoints.length; i++) {
                    createAnt(screenPoints[i].x, screenPoints[i].y);
                }
            }
            
            function createAnt(x, y) {
                const ant = {
                    x,
                    y,
                    size: 1.8 + Math.random() * 1.0, // Consistent sized ants
                    angle: Math.random() * Math.PI * 2, 
                    speed: 0.8 + Math.random() * 1.2, // Slightly faster movement
                    wiggleSpeed: 0.1 + Math.random() * 0.2,
                    pathIndex: Math.floor(Math.random() * Math.max(1, paths.length)),
                    pathPosition: Math.floor(Math.random() * 100),
                    followingText: false,
                    textFormationIndex: -1,
                    targetX: x,
                    targetY: y,
                    textTargetX: 0,
                    textTargetY: 0,
                    legSpeed: 0.2 + Math.random() * 0.3,
                    stuck: 0,
                    lastX: x,
                    lastY: y,
                    inTransit: true,  // Ants are initially moving towards the drawn path
                    arrivalDelay: Math.random() * 80 // Reduced arrival delay
                };
                
                // Set initial target to center screen if no paths yet
                if (paths.length === 0) {
                    ant.targetX = canvas.width / 2;
                    ant.targetY = canvas.height / 2;
                } else {
                    // Target an existing path
                    const randomPath = paths[Math.floor(Math.random() * paths.length)];
                    const randomPoint = randomPath[Math.floor(Math.random() * randomPath.length)];
                    ant.targetX = randomPoint.x;
                    ant.targetY = randomPoint.y;
                }
                
                ants.push(ant);
            }
            
            function startTextFormation() {
                generateTextPoints();
                
                // Assign ants to all text formations with less delay
                let timeOffset = 0;
                for (let i = 0; i < formationSteps.length; i++) {
                    setTimeout(() => {
                        assignAntsToFormation(i);
                    }, timeOffset);
                    timeOffset += 500; // Shorter delay between formations
                }
            }
            
            function generateTextPoints() {
                textFormations = [];
                buttonAreas = [];
                
                for (let i = 0; i < formationSteps.length; i++) {
                    const step = formationSteps[i];
                    const centerX = canvas.width / 2;
                    
                    // Create offscreen canvas for text
                    const offCanvas = document.createElement('canvas');
                    offCanvas.width = canvas.width;
                    offCanvas.height = canvas.height;
                    const offCtx = offCanvas.getContext('2d');
                    
                    // Draw text to offscreen canvas with higher clarity
                    offCtx.font = `bold ${step.fontSize}px Arial`;
                    offCtx.fillStyle = "rgba(0,0,0,1)";
                    offCtx.textAlign = "center";
                    offCtx.fillText(step.text, centerX, step.y);
                    
                    // Get image data
                    const imageData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);
                    const pixels = imageData.data;
                    
                    // Sample points with higher density for clearer text
                    const points = [];
                    const sampleRate = i === 0 ? 0.8 : 1.2; // More dense sampling for title
                    
                    for (let y = 0; y < offCanvas.height; y += sampleRate) {
                        for (let x = 0; x < offCanvas.width; x += sampleRate) {
                            const index = (Math.floor(y) * offCanvas.width + Math.floor(x)) * 4;
                            if (pixels[index + 3] > 0) {
                                points.push({ x, y });
                            }
                        }
                    }
                    
                    textFormations.push(points);
                    
                    // Create button area for click detection (except title)
                    if (i > 0) {
                        const textWidth = offCtx.measureText(step.text).width;
                        buttonAreas.push({
                            x: centerX - textWidth / 2 - 20,
                            y: step.y - step.fontSize - 10,
                            width: textWidth + 40,
                            height: step.fontSize + 20,
                            action: step.text
                        });
                    }
                }
            }
            
            function assignAntsToFormation(formationIndex) {
                if (formationIndex >= textFormations.length) return;
                
                const points = textFormations[formationIndex];
                if (!points || points.length === 0) return;
                
                // Determine how many ants to use for this formation
                // Allocate more ants for title and proportionally for each menu item
                let antsPerFormation;
                if (formationIndex === 0) {
                    antsPerFormation = Math.min(Math.floor(ants.length * 0.35), points.length); // 35% for title
                } else {
                    // Distribute remaining ants across menu items
                    antsPerFormation = Math.min(Math.floor(ants.length * 0.11), points.length); // ~11% for each menu item
                }
                
                // Find ants that are not already in a formation
                const availableAnts = ants.filter(ant => !ant.followingText);
                
                // If not enough ants, use all available
                const antsToAssign = Math.min(antsPerFormation, availableAnts.length);
                
                // Assign points to ants - ensure we distribute evenly for best visibility
                for (let i = 0; i < antsToAssign; i++) {
                    const ant = availableAnts[i];
                    // Distribute ants evenly across available points
                    const pointIndex = Math.floor((i / antsToAssign) * points.length);
                    
                    ant.followingText = true;
                    ant.textFormationIndex = formationIndex;
                    ant.textTargetX = points[pointIndex].x;
                    ant.textTargetY = points[pointIndex].y;
                    ant.inTransit = false;
                    
                    // Boost speed for text formation
                    ant.speed = 2.0 + Math.random() * 0.5;
                }
                
                currentFormationStep = formationIndex;
            }
            
            function drawAnt(ant) {
                // Save context
                ctx.save();
                
                // Move to ant position and rotate
                ctx.translate(ant.x, ant.y);
                ctx.rotate(ant.angle);
                
                // Draw ant body - make cleaner for better text definition
                ctx.fillStyle = 'black';
                
                // Head
                ctx.beginPath();
                ctx.ellipse(ant.size * 0.8, 0, ant.size * 0.5, ant.size * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Thorax
                ctx.beginPath();
                ctx.ellipse(0, 0, ant.size * 0.4, ant.size * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Abdomen
                ctx.beginPath();
                ctx.ellipse(-ant.size * 1.2, 0, ant.size * 0.7, ant.size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw legs - simpler legs for cleaner appearance
                if (!ant.followingText || Math.random() < 0.7) { // Limit leg drawing for text-forming ants
                    ctx.lineWidth = ant.size * 0.15;
                    ctx.strokeStyle = 'black';
                    
                    // Calculate leg positions with wiggle
                    const legTime = Date.now() * ant.legSpeed;
                    const frontLegWiggle = Math.sin(legTime) * 0.3;
                    const midLegWiggle = Math.sin(legTime + 1) * 0.3;
                    const backLegWiggle = Math.sin(legTime + 2) * 0.3;
                    
                    // Front legs
                    ctx.beginPath();
                    ctx.moveTo(ant.size * 0.5, 0);
                    ctx.lineTo(ant.size * 0.5, ant.size * (1.2 + frontLegWiggle));
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(ant.size * 0.5, 0);
                    ctx.lineTo(ant.size * 0.5, -ant.size * (1.2 - frontLegWiggle));
                    ctx.stroke();
                    
                    // Middle legs
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, ant.size * (1.4 + midLegWiggle));
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -ant.size * (1.4 - midLegWiggle));
                    ctx.stroke();
                    
                    // Back legs
                    ctx.beginPath();
                    ctx.moveTo(-ant.size * 0.8, 0);
                    ctx.lineTo(-ant.size * 0.8, ant.size * (1.6 + backLegWiggle));
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(-ant.size * 0.8, 0);
                    ctx.lineTo(-ant.size * 0.8, -ant.size * (1.6 - backLegWiggle));
                    ctx.stroke();
                }
                
                // Restore context
                ctx.restore();
            }
            
            function updateAnt(ant) {
                // Wait for arrival delay before moving
                if (ant.arrivalDelay > 0) {
                    ant.arrivalDelay--;
                    return;
                }
                
                // Save last position to check for stuckness
                ant.lastX = ant.x;
                ant.lastY = ant.y;
                
                if (ant.followingText) {
                    // Move toward text formation position
                    const dx = ant.textTargetX - ant.x;
                    const dy = ant.textTargetY - ant.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 1.2) {
                        const targetAngle = Math.atan2(dy, dx);
                        
                        // Gradually rotate toward target
                        let angleDiff = targetAngle - ant.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        ant.angle += angleDiff * 0.4; // Faster turning for more precise text
                        
                        // Reduce random wiggle for text formation
                        ant.angle += (Math.random() - 0.5) * 0.01;
                        
                        // Move forward with distance-based speed
                        const moveSpeed = Math.min(distance * 0.4, ant.speed * 1.5);
                        ant.x += Math.cos(ant.angle) * moveSpeed;
                        ant.y += Math.sin(ant.angle) * moveSpeed;
                    } else {
                        // Small random movement to make it look alive
                        ant.angle += (Math.random() - 0.5) * 0.05;
                        ant.x += Math.cos(ant.angle) * 0.1;
                        ant.y += Math.sin(ant.angle) * 0.1;
                    }
                } else if (ant.inTransit) {
                    // Move toward initial target (drawn path or center)
                    const dx = ant.targetX - ant.x;
                    const dy = ant.targetY - ant.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 5) {
                        const targetAngle = Math.atan2(dy, dx);
                        
                        // Gradually rotate toward target
                        let angleDiff = targetAngle - ant.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        ant.angle += angleDiff * 0.2;
                        
                        // Add some random wiggle to movement
                        ant.angle += (Math.random() - 0.5) * 0.08;
                        
                        // Move forward with varying speed based on distance
                        const moveSpeed = Math.min(distance * 0.15, ant.speed);
                        ant.x += Math.cos(ant.angle) * moveSpeed;
                        ant.y += Math.sin(ant.angle) * moveSpeed;
                    } else {
                        // Reached the target, start following path or start forming text
                        ant.inTransit = false;
                    }
                } else {
                    // Follow path if there are any
                    const pathsCount = paths.length;
                    if (pathsCount > 0) {
                        // Make sure pathIndex is valid
                        ant.pathIndex = ant.pathIndex % pathsCount;
                        
                        const path = paths[ant.pathIndex];
                        if (!path || path.length === 0) return;
                        
                        // Update position along path
                        ant.pathPosition += ant.speed * 0.5;
                        if (ant.pathPosition >= path.length) {
                            // Jump to another path occasionally
                            if (Math.random() < 0.1) {
                                ant.pathIndex = Math.floor(Math.random() * pathsCount);
                            }
                            ant.pathPosition = 0;
                        }
                        
                        const targetIndex = Math.floor(ant.pathPosition) % path.length;
                        const target = path[targetIndex];
                        
                        // Calculate direction to target
                        const dx = target.x - ant.x;
                        const dy = target.y - ant.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const targetAngle = Math.atan2(dy, dx);
                        
                        // Gradually rotate toward target
                        let angleDiff = targetAngle - ant.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        ant.angle += angleDiff * 0.2;
                        
                        // Add some random wiggle to movement
                        ant.angle += (Math.random() - 0.5) * ant.wiggleSpeed;
                        
                        // Move forward
                        const moveSpeed = Math.min(distance * 0.2, ant.speed);
                        ant.x += Math.cos(ant.angle) * moveSpeed;
                        ant.y += Math.sin(ant.angle) * moveSpeed;
                        
                        // Occasionally jump to a random nearby position to simulate more chaotic movement
                        if (Math.random() < 0.005) {
                            ant.x += (Math.random() - 0.5) * 15;
                            ant.y += (Math.random() - 0.5) * 15;
                        }
                    } else {
                        // Random movement if no path
                        ant.angle += (Math.random() - 0.5) * 0.1;
                        ant.x += Math.cos(ant.angle) * 0.5;
                        ant.y += Math.sin(ant.angle) * 0.5;
                    }
                }
                
                // Check if stuck
                const movedDistance = Math.sqrt(
                    Math.pow(ant.x - ant.lastX, 2) + 
                    Math.pow(ant.y - ant.lastY, 2)
                );
                
                if (movedDistance < 0.1) {
                    ant.stuck++;
                    if (ant.stuck > 10) { // Reduced stuck threshold for more responsive movement
                        // Ant is stuck, give it a random kick
                        ant.angle += Math.PI * (0.5 + Math.random());
                        ant.x += Math.cos(ant.angle) * 10;
                        ant.y += Math.sin(ant.angle) * 10;
                        ant.stuck = 0;
                        
                        if (ant.followingText && Math.random() < 0.6) {
                            // Assign a new target point from the same text formation
                            const formationPoints = textFormations[ant.textFormationIndex];
                            if (formationPoints && formationPoints.length > 0) {
                                const newTargetIndex = Math.floor(Math.random() * formationPoints.length);
                                ant.textTargetX = formationPoints[newTargetIndex].x;
                                ant.textTargetY = formationPoints[newTargetIndex].y;
                            }
                        }
                    }
                } else {
                    ant.stuck = 0;
                }
                
                // Keep ants on screen
                if (ant.x < 0) ant.x = 0;
                if (ant.y < 0) ant.y = 0;
                if (ant.x > canvas.width) ant.x = canvas.width;
                if (ant.y > canvas.height) ant.y = canvas.height;
            }
            
            function checkButtonClick(x, y) {
                for (let i = 0; i < buttonAreas.length; i++) {
                    const button = buttonAreas[i];
                    if (x >= button.x && x <= button.x + button.width &&
                        y >= button.y && y <= button.y + button.height) {
                        
                        handleButtonAction(button.action);
                        return true;
                    }
                }
                return false;
            }
            
            // Modified button action handler to use saved skins
            function handleButtonAction(action) {
                // Get saved skins from localStorage with fallback to defaults
                const lastChat = localStorage.getItem("lastChatSkin") || 'chatpage';
                const lastVoice = localStorage.getItem("lastVoiceSkin") || 'voice_mode.html';
                const lastFace = localStorage.getItem("lastFaceSkin") || 'face_mode.html';

                if (action === 'New Chat') {
                    window.location.href = `/${lastChat}`;
                } 
                else if (action === 'About Me') {
                    window.location.href = '/aboutme';
                }
                else if (action === 'Exit') {
                    document.getElementById('exitModal').style.display = 'flex';
                }
                else if (action === 'Neon Shift') {
                    window.location.href = '/selector';
                }
                else if (action === 'Voice Mode') {
                    showLoading('Initializing Voice Mode...');
                    fetch('/voice-mode')
                        .then(() => {
                            window.location.href = `/${lastVoice}`;
                        })
                        .catch(error => {
                            hideLoading();
                            console.error('Voice Mode Error:', error);
                            alert('Failed to launch Voice Mode: ' + error.message);
                        });
                }
                else if (action === 'Face Mode') {
                    showLoading('Initializing Face Mode...');
                    fetch('/face-mode')
                        .then(() => {
                            window.location.href = `/${lastFace}`;
                        })
                        .catch(error => {
                            hideLoading();
                            console.error('Face Mode Error:', error);
                            alert('Failed to launch Face Mode: ' + error.message);
                        });
                }
            }
            
            function scatterAntsFromButton(formationIndex) {
                // Make ants from this button scatter
                for (let i = 0; i < ants.length; i++) {
                    if (ants[i].followingText && ants[i].textFormationIndex === formationIndex) {
                        ants[i].followingText = false;
                        ants[i].inTransit = true;
                        ants[i].angle = Math.random() * Math.PI * 2;
                        ants[i].speed = 1 + Math.random() * 3;
                        
                        // Set random targets
                        ants[i].targetX = Math.random() * canvas.width;
                        ants[i].targetY = Math.random() * canvas.height;
                    }
                }
                
                // Re-form the button after a delay
                setTimeout(() => {
                    assignAntsToFormation(formationIndex);
                }, 2000);
            }
            
            function scatterAllAnts() {
                // Make all ants run in random directions
                for (let i = 0; i < ants.length; i++) {
                    ants[i].followingText = false;
                    ants[i].inTransit = true;
                    ants[i].angle = Math.random() * Math.PI * 2;
                    ants[i].speed = 1 + Math.random() * 3;
                    
                    // Set random targets at the edges
                    if (Math.random() < 0.25) {
                        ants[i].targetX = 0;
                    } else if (Math.random() < 0.5) {
                        ants[i].targetX = canvas.width;
                    } else {
                        ants[i].targetX = Math.random() * canvas.width;
                    }
                    
                    if (Math.random() < 0.25) {
                        ants[i].targetY = 0;
                    } else if (Math.random() < 0.5) {
                        ants[i].targetY = canvas.height;
                    } else {
                        ants[i].targetY = Math.random() * canvas.height;
                    }
                }
                
                // Reset formation after a delay
                setTimeout(() => {
                    startTextFormation();
                }, 3000);
            }
            
            // Loading indicator functions
            function showLoading(message) {
                document.getElementById('loadingText').textContent = message;
                document.getElementById('loadingIndicator').style.display = 'flex';
            }
            
            function hideLoading() {
                document.getElementById('loadingIndicator').style.display = 'none';
            }
            
            // Exit modal buttons - Updated to match holo.html behavior
            document.getElementById('confirmExit').addEventListener('click', () => {
                showLoading('Closing system...');
                fetch('/exit', { method: 'POST' })
                    .then(() => console.log("Exit requested"))
                    .catch(err => {
                        console.error("Exit failed", err);
                        hideLoading();
                    });
            });
            
            document.getElementById('cancelExit').addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                document.getElementById('exitModal').style.display = 'none';
            });
            
            // Handle button click - prevent triggering when clicking modal buttons
            document.addEventListener('click', (e) => {
                // Only process clicks if they're not on the modal or its buttons
                if (!e.target.closest('#exitModal') && !e.target.closest('.modal-button')) {
                    checkButtonClick(e.clientX, e.clientY);
                }
            });
            
            // Auto-start the swarm
            createAntSwarm();
            startTextFormation();
            
            function animate() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Update and draw all ants
                for (let i = 0; i < ants.length; i++) {
                    updateAnt(ants[i]);
                    drawAnt(ants[i]);
                }
                
                // Request next frame
                requestAnimationFrame(animate);
            }
            
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Update formation steps y-positions based on new height
                for (let i = 0; i < formationSteps.length; i++) {
                    if (i === 0) {
                        formationSteps[i].y = canvas.height * 0.25;
                    } else {
                        formationSteps[i].y = canvas.height * (0.4 + (i-1) * 0.1);
                    }
                }
                
                // Re-generate text formations
                if (hasSpawnedSwarm) {
                    // Reset all ants
                    for (let i = 0; i < ants.length; i++) {
                        ants[i].followingText = false;
                        ants[i].inTransit = true;
                    }
                    
                    // Start formation again
                    setTimeout(() => {
                        startTextFormation();
                    }, 300);
                }
            });
            
            // Start animation
            animate();
        }

        // Add event listeners for black hole animation
        document.body.addEventListener('click', startAnimation);
        document.querySelectorAll('.button').forEach(button => {
            button.addEventListener('click', event => {
                event.stopPropagation();  // Prevent double triggering
                startAnimation();
            });
        });

        // Skip to Ant Interface on Space Bar
        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space') {
                // Hide Black Hole and Paint Sections instantly
                document.querySelector('.container').style.display = 'none';
                document.getElementById('paint-section').style.display = 'none';
                // Start Ant Interface directly
                startAntInterface();
            }
        });
    </script>
</body>
</html>